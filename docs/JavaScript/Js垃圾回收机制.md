# JS 垃圾回收机制

## 什么是垃圾回收机制

**垃圾回收** 俗称`GC`全称`Garbage Collection`。代码程序在执行过程中会产生很多垃圾，`这些垃圾`是程序不用的内存或者是之前用过了，并且以后不会再用的内存空间。所以`GC`就是负责回收垃圾的，因为工作在`JS引擎`内部，所以对于我们前端来说，GC 过程是相对比较陌生的，这一套引擎执行而对我们又相对陌生的操作就是我们面试老说的`垃圾回收机制`。

## 垃圾如何产生

我们都知道在写代码时创建一个基本类型、对象、函数……吧啦吧啦都是需要占用内存的，但是我们并不关注这些，因为这是`JS引擎`为我们分配的，我们不需要自己去分配内存。

**提问环节**

<p style="color: rgb(100, 181, 135);">大家想一想，当我们不再需要某个数据时？JavaScript 引擎又是如何发现并清理它的呢？</p>

行了，想这么多也没啥意思。我们都知道 JavaScript 的引用数据类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用(查找地址)，所以，JavaScript 中对引用数据类型的操作都是操作对象的引用而不是实际的对象。可以简单理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的。 直接看代码吧！

```js
// example
let test = {
  name: "工藤新一",
};
test = [1, 2, 3, 4, 5, 6, 7, 8];
```

首先我们声明了一个变量 test，它引用了对象 {name: "工藤新一"}，接着我们把这个变量重新赋值了一个数组对象，也就变成了该变量引用了一个数组，那么之前的对象引用关系就没有了。既然没了引用关系，也就是垃圾，这个时候假如把它放那不管，一个两个还行，多了的话内存那不得挤死啊，所以就需要被清理（回收）

<img src="/js回收1.png" style="margin-left:5%"/>

## 垃圾回收算法策略

JavaScript 垃圾回收机制的原理说白了也就是定期找出那些不再用到的内存（变量），然后释放其内存。但是把垃圾也没那么好找，所以嘞，怎么找出垃圾这个流程就会涉及到一些算法策略，这里就说两种大家面试老生常谈的。

- 标记清除算法
- 引用计数算法

### 标记清除算法

**标记清除**（Mark-Sweep），目前在 `JavaScript引擎` 里这种算法是最常用的，到目前为止的大多数浏览器的 JavaScript 引擎 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 `JavaScript引擎` 在运行垃圾回收的频率上有所差异

> 顾名思义，先标记后清除，分为两个阶段。

- **标记阶段**: 给所有被用到的对象做个标记
- **清除阶段**: 把那些没有标记的对象销毁

整个标记清除算法的过程粗略 say 下：

- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0
- 然后从各个根对象开始遍历，把不是垃圾的节点改成 1
- 清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间
- 最后，把所有内存中对象标记修改为 0，等待下一轮垃圾回收

**优点：**  
实现起来比较简单，打标记也无非打与不打两种情况，这样一位二进制位（0 和 1）就可以为其标记，这不是 so easy 嘛！

**缺点：**  
标记清除算法的问题倒是蛮大的，每次清除阶段执行之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了`内存碎片`,并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题
<img src="/noticeFn1.png">

> 标记清除算法的缺点：

- 1、内存碎片化
- 2、大内存分配效率低

### 引用计数算法

**引用计数**(Reference Counting)，这也算是一款比较早的垃圾回收算法，它把**标记清除**中的`对象是否不再需要`简化定义为`对象有没有被其他对象引用到它`，如果没有引用指向该对象，那就是无引用，那这样的对象就会被垃圾回收机制回收了。But 问题有点多，所以用的不多了哈。

首先要搞清楚，引用计数算法它的思想是跟踪每个变量值被使用的次数。

```js
let a = []; // 首先a数组的引用计数 = 1
let b = a; // 我再把a赋值给b，数组的引用 = 2
a = null; // 我把变量a滞空，数组的引用 2 - 1 = 1，此时只有b还在引用着数组
b = null; // 我把变量b滞空，数组的应用 = 0
// 此时 GC就来回收啦！
```

> 上面的例子，看着好像没多大问题哈，那接下来看一下循环引用的示例

```js
function XiaoXinTest() {
  let A = {};
  let B = new Object();

  A.b = B;
  B.a = A;
}

XiaoXinTest();
// 大家看，XiaoXinTest这个函数一旦执行完成，按道理来说里面的内存都应该被清除吧，
// 可是，函数内部的对象A、对象B通过各自的属性a、b相互引用着。所以那两个对象的引用不会变成0，
// 这样搞，不浪费内存鬼信！
```

> 那可以考虑一下，如何解决上述例子中循环引用的问题

```js
function XiaoXinTest() {
  let A = {};
  let B = new Object();
  // 从这里开始，造成了循环引用
  A.b = B;
  B.a = A;
  // 那我们统一给它引用制空
  A.b = null;
  B.a = null;
}

XiaoXinTest();
// 这样不就切断了引用关系
```

**优点：**  
引用计数算法相比标记清除算法看起来更加清晰，引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，它就可以立即回收垃圾。  
标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以

**缺点：**  
得需要个计数器（不知上限所以会占空间），且循环引用的问题无法解决

## V8 引擎对 GC 的优化

在上述中我提到了，现在很多浏览器用的都还是标记清除算法，当然 V8 也没有例外。不过哈，V8 在原有的基础上优化加工，接下来我要提到一个新名词 <span style="color: rgb(100, 181, 135);fontWeight:700">分代式垃圾回收</span>

### 分代式垃圾回收

> 提个问题，纯字面意思你觉得分代式拉圾回收是什么？

算了不卖关子了，分代式就是新老生代，从上文大家就知道了一些内存存在的时间可能很长，一些内存刚用完就要被回收了。这样一来就演绎出了新老生代的说法。

### 新老生代

V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收

**新生代**的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1 ～ 8M 的容量，而**老生代**的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大

V8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）

<img src="/newOldMemory.png" />

对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器，同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器好了

#### 新、老生代垃圾回收

新生代对象是通过一个名为 **Scavenge** 的算法进行垃圾回收，在 **Scavenge** 算法 的具体实现中，主要采用了一种复制式的方法即 **Cheney** 算法 ，我们细细道来
**Cheney** 算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为 空闲区，如下图所示

<img src="/leisure.png" />

对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了

说这么多，我都要看糊涂了，我给大家总结一段话，来讲清楚分代式拉圾回收的工作流程。

> 这个过程是这样的：  
> 首先新生代分使用区和空闲区，当使用区快满了，就要开始 GC 了，
> 然后开始对使用区做标记，标记后复制一份活动对象到空闲区（这里做了整理的操作，也就是排序，避免内存碎片），
> 再然后清除使用区数据对象，把原来的使用区改称空闲区，把原来的空闲区改成使用区，这样的话新使用区就是空的。  
> 继续存数据，当快存满了开始下一轮 GC，再看第二轮 GC，还是重复上面的步骤，先标记，再把活动对象从使用区复制到空闲区，这个时候假如发现了上次就存在的对象这次还是活动对象，`那这个对象就会被晋级`，扔到老生代里去。接着说复制之后，使用区又被清空了，并且再次和空闲区转换，那每一轮 GC 过后，使用区就会变成空的。

> 我感觉说的挺明白了，听不明白的拉出去砍了！

### 更多

其实 V8 对 GC 还有其他的优化，比如**并行回收**、**增量标记**、**惰性清理** 等等，这里就不一一说了，大家感兴趣可以去度娘看。

> 学无止 尽！建议大家看个大概，理解其主要含义是最好的
