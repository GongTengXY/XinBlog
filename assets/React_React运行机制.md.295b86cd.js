import{_ as e,o as i,c as r,a as t}from"./app.5acfab91.js";const g=JSON.parse('{"title":"React 运行机制","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. 初始化加载（Mounting 阶段）","slug":"_1-初始化加载-mounting-阶段","link":"#_1-初始化加载-mounting-阶段","children":[{"level":3,"title":"1、浏览器加载 HTML 与 JavaScript：","slug":"_1、浏览器加载-html-与-javascript","link":"#_1、浏览器加载-html-与-javascript","children":[]},{"level":3,"title":"2、React 初始化与根 Fiber 创建：","slug":"_2、react-初始化与根-fiber-创建","link":"#_2、react-初始化与根-fiber-创建","children":[]},{"level":3,"title":"3、初次 Reconciliation 与 Commit 阶段：","slug":"_3、初次-reconciliation-与-commit-阶段","link":"#_3、初次-reconciliation-与-commit-阶段","children":[]}]},{"level":2,"title":"2. 用户操作触发状态更新","slug":"_2-用户操作触发状态更新","link":"#_2-用户操作触发状态更新","children":[{"level":3,"title":"1、事件触发与状态更新：","slug":"_1、事件触发与状态更新","link":"#_1、事件触发与状态更新","children":[]},{"level":3,"title":"2、调度更新任务：","slug":"_2、调度更新任务","link":"#_2、调度更新任务","children":[]}]},{"level":2,"title":"3. 更新过程（Reconciliation 与 Commit）","slug":"_3-更新过程-reconciliation-与-commit","link":"#_3-更新过程-reconciliation-与-commit","children":[{"level":3,"title":"1、创建 Work-in-Progress 树：","slug":"_1、创建-work-in-progress-树","link":"#_1、创建-work-in-progress-树","children":[]},{"level":3,"title":"2、Diff 过程（Reconciliation）：","slug":"_2、diff-过程-reconciliation","link":"#_2、diff-过程-reconciliation","children":[]},{"level":3,"title":"3、Fiber 架构与时间切片：","slug":"_3、fiber-架构与时间切片","link":"#_3、fiber-架构与时间切片","children":[]},{"level":3,"title":"4、Commit 阶段：","slug":"_4、commit-阶段","link":"#_4、commit-阶段","children":[]}]},{"level":2,"title":"4. 更新过程的整体流程总结","slug":"_4-更新过程的整体流程总结","link":"#_4-更新过程的整体流程总结","children":[]},{"level":2,"title":"5. 相关概念的补充说明","slug":"_5-相关概念的补充说明","link":"#_5-相关概念的补充说明","children":[]}],"relativePath":"React/React运行机制.md","lastUpdated":1741504244000}'),a={name:"React/React运行机制.md"},n=t('<h1 id="react-运行机制" tabindex="-1">React 运行机制 <a class="header-anchor" href="#react-运行机制" aria-hidden="true">#</a></h1><p>我将以从 URL 输入到页面状态更新过程中，React 底层发生的整个流程，来理解框架的运行机制与渲染流程。</p><h2 id="_1-初始化加载-mounting-阶段" tabindex="-1">1. 初始化加载（Mounting 阶段） <a class="header-anchor" href="#_1-初始化加载-mounting-阶段" aria-hidden="true">#</a></h2><h3 id="_1、浏览器加载-html-与-javascript" tabindex="-1">1、浏览器加载 HTML 与 JavaScript： <a class="header-anchor" href="#_1、浏览器加载-html-与-javascript" aria-hidden="true">#</a></h3><p>当用户在地址栏中输入 URL 并访问页面时，浏览器会加载 HTML 文件，该文件中包含了挂载 React 应用的容器以及引入的 React 相关的 JavaScript 代码（通常是打包后的 bundle）。</p><h3 id="_2、react-初始化与根-fiber-创建" tabindex="-1">2、React 初始化与根 Fiber 创建： <a class="header-anchor" href="#_2、react-初始化与根-fiber-创建" aria-hidden="true">#</a></h3><p>React 在启动时，会为根组件创建一个 Fiber 节点。此时，React 会遍历组件树，根据组件的返回值构建出一个虚拟 DOM（Virtual DOM）的抽象表示，并同时生成对应的 Fiber 树。这棵 Fiber 树包含了组件的状态、属性、子组件信息以及副作用等信息。</p><h3 id="_3、初次-reconciliation-与-commit-阶段" tabindex="-1">3、初次 Reconciliation 与 Commit 阶段： <a class="header-anchor" href="#_3、初次-reconciliation-与-commit-阶段" aria-hidden="true">#</a></h3><ul><li><strong>Reconciliation 阶段：</strong> React 会根据虚拟 DOM 和 Fiber 树构建出当前的渲染树，此时所有组件的初始状态都已确定。</li><li><strong>Commit 阶段：</strong> 在这一阶段，React 会将 Fiber 树中记录的变化（对于初次渲染，就是整个树）转化为真实 DOM 元素，并挂载到页面的根容器中。</li></ul><p>此时，用户看到的就是页面的初始渲染结果，也就是“当前树”（Current Tree）。</p><h2 id="_2-用户操作触发状态更新" tabindex="-1">2. 用户操作触发状态更新 <a class="header-anchor" href="#_2-用户操作触发状态更新" aria-hidden="true">#</a></h2><p>假设页面上有一个按钮，用户点击后触发了状态更新（例如调用了 setState 或者使用 Hooks 更新状态）。</p><h3 id="_1、事件触发与状态更新" tabindex="-1">1、事件触发与状态更新： <a class="header-anchor" href="#_1、事件触发与状态更新" aria-hidden="true">#</a></h3><p>当用户点击按钮时，React 的合成事件系统捕获到该事件，然后调用相应的事件处理函数。在该函数中，调用 setState 或 Hooks 更新状态的函数，这会创建一个更新任务。</p><h3 id="_2、调度更新任务" tabindex="-1">2、调度更新任务： <a class="header-anchor" href="#_2、调度更新任务" aria-hidden="true">#</a></h3><p>React 调度器根据当前任务的优先级（例如用户交互属于高优先级任务），将这个状态更新任务排入任务队列。由于更新任务通常不是同步执行的，React 会开始构建新的更新。</p><h2 id="_3-更新过程-reconciliation-与-commit" tabindex="-1">3. 更新过程（Reconciliation 与 Commit） <a class="header-anchor" href="#_3-更新过程-reconciliation-与-commit" aria-hidden="true">#</a></h2><h3 id="_1、创建-work-in-progress-树" tabindex="-1">1、创建 Work-in-Progress 树： <a class="header-anchor" href="#_1、创建-work-in-progress-树" aria-hidden="true">#</a></h3><ul><li><strong>Current Tree 与 Work-in-Progress Tree：</strong> React 内部维护两棵树，一棵是当前已经提交的 Fiber 树（Current Tree），另一棵是正在构建的新 Fiber 树（Work-in-Progress Tree），两者之间通过每个 Fiber 节点的 alternate 属性相互关联。</li><li>当状态更新触发时，React 会基于当前树创建一棵新的 Work-in-Progress 树，用于存放本次更新的结果。</li></ul><h3 id="_2、diff-过程-reconciliation" tabindex="-1">2、Diff 过程（Reconciliation）： <a class="header-anchor" href="#_2、diff-过程-reconciliation" aria-hidden="true">#</a></h3><ul><li>React 通过比较新旧 虚拟 dom 对应节点（利用 Diff 算法），来找出哪些部分发生了变化。</li><li>在这个过程中，React 会标记出需要更新的节点，并生成一个“副作用列表”（Effect List），记录所有将要在 Commit 阶段应用的 DOM 变更。</li></ul><h3 id="_3、fiber-架构与时间切片" tabindex="-1">3、Fiber 架构与时间切片： <a class="header-anchor" href="#_3、fiber-架构与时间切片" aria-hidden="true">#</a></h3><ul><li>任务拆分： Fiber 架构将整个更新任务拆分为一个个小的任务单元（Fiber 单元），可以在多个时间片中完成。</li><li>可中断执行： 如果在执行过程中检测到高优先级任务（如新的用户输入）到来，React 会暂停当前的更新任务，保存当前进度，然后稍后继续执行（这就保证了即使是大量更新也不会长时间阻塞主线程）。执行后的结果会应用到我们的 workInProgress Tree 上，来保存我们更新的结果。</li></ul><h3 id="_4、commit-阶段" tabindex="-1">4、Commit 阶段： <a class="header-anchor" href="#_4、commit-阶段" aria-hidden="true">#</a></h3><ul><li>一旦 Work-in-Progress 树构建完成，并且所有差异都被确定，React 会进入 Commit 阶段。</li><li>在 Commit 阶段，React 会根据副作用列表把更新应用到真实 DOM 上，例如更新文本内容、属性变更、插入或删除节点等。</li><li>此时，新的 UI 状态呈现在用户眼前，Work-in-Progress 树正式替换当前树，成为新的 Current Tree。</li></ul><h2 id="_4-更新过程的整体流程总结" tabindex="-1">4. 更新过程的整体流程总结 <a class="header-anchor" href="#_4-更新过程的整体流程总结" aria-hidden="true">#</a></h2><ul><li><p><strong>初始加载阶段：</strong> 浏览器加载 HTML 与 JS → React 创建根 Fiber 节点 → 构建初始虚拟 DOM 和 Fiber 树 → 进入 Commit 阶段，将真实 DOM 渲染到页面上 → 当前树构建完毕。</p></li><li><p><strong>状态更新过程：</strong> 用户操作触发事件 → 调用 setState / Hooks 更新状态 → React 调度器将更新任务入队 → 基于当前树创建 Work-in-Progress 树 → 执行 Diff 过程（Reconciliation 协调阶段）生成副作用列表 → 任务可能通过时间切片分多次执行（支持中断与恢复） → 进入 Commit 阶段，将需要变更的项 应用到真实 DOM 上 → Work-in-Progress 树成为新的 Current Tree。</p></li></ul><h2 id="_5-相关概念的补充说明" tabindex="-1">5. 相关概念的补充说明 <a class="header-anchor" href="#_5-相关概念的补充说明" aria-hidden="true">#</a></h2><ul><li><p><strong>合成事件系统：</strong> React 通过合成事件封装原生事件，利用事件委托机制将事件绑定到根节点，统一处理跨浏览器兼容性问题。 事件对象经过池化处理，降低内存分配成本。</p></li><li><p><strong>虚拟 DOM 与 Fiber：</strong> 虚拟 DOM 为 React 提供了高效的树结构抽象，Diff 算法对比前后状态；而 Fiber 架构则细化了渲染过程，使其支持中断、调度与恢复，进一步提升响应性和用户体验。</p></li><li><p><strong>Current Tree 与 Work-in-Progress Tree：</strong> 这种双树机制允许 React 在更新过程中始终保留当前已渲染的 UI，同时在后台构建新的更新，避免了不必要的重绘和性能损耗。</p></li><li><p><strong>副作用链（Effect List）：</strong> 在 Reconciliation 过程中，React 会收集所有需要在 Commit 阶段执行的副作用（比如 DOM 更新、生命周期方法调用等），这使得更新过程更具可控性和一致性。</p></li><li><p><strong>时间切片与调度器：</strong> 通过任务拆分和时间切片，React 能够灵活安排长任务，使得高优先级任务（如用户输入）能够及时得到响应，从而保证应用整体的流畅性。</p></li></ul>',29),l=[n];function o(c,s,h,d,_,m){return i(),r("div",null,l)}const f=e(a,[["render",o]]);export{g as __pageData,f as default};
