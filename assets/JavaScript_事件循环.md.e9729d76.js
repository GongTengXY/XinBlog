import{_ as s,o as n,c as l,a}from"./app.5acfab91.js";const C=JSON.parse('{"title":"事件循环","description":"","frontmatter":{},"headers":[{"level":2,"title":"同步任务","slug":"同步任务","link":"#同步任务","children":[]},{"level":2,"title":"异步任务","slug":"异步任务","link":"#异步任务","children":[]},{"level":2,"title":"浏览器的事件循环机制","slug":"浏览器的事件循环机制","link":"#浏览器的事件循环机制","children":[]},{"level":2,"title":"Nodejs 的事件循环机制","slug":"nodejs-的事件循环机制","link":"#nodejs-的事件循环机制","children":[]}],"relativePath":"JavaScript/事件循环.md","lastUpdated":1741504244000}'),o={name:"JavaScript/事件循环.md"},p=a(`<h1 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-hidden="true">#</a></h1><div class="info custom-block"><p class="custom-block-title">前方引言</p><p>在讲解事件循环之前，我们先回顾一下相关知识点</p></div><p>JavaScript 是一门单线程执行的编程语言。也就是说，同一时间只能做一件事情。单线程执行任务队列的问题: 如果前一个任务非常耗时，则后续的任务就不得不一直等待，从而导致程序假死的问题。为了防止某个耗时任务导致程序假死的问题，JavaScript 把待执行的任务分为了两类:</p><h2 id="同步任务" tabindex="-1">同步任务 <a class="header-anchor" href="#同步任务" aria-hidden="true">#</a></h2><p>又叫做非耗时任务，指的是在<strong>主线程</strong>上排队执行的那些任务，只有前一个任务执行完毕，才能执行后一个任务</p><h2 id="异步任务" tabindex="-1">异步任务 <a class="header-anchor" href="#异步任务" aria-hidden="true">#</a></h2><p>不直接在主线程上执行的任务，它们会先被放入任务队列中，等到主线程空闲时才执行。</p><p><strong>异步任务的分类:</strong></p><p>异步任务又分为<strong>宏任务</strong>、<strong>微任务</strong>，</p><ul><li>宏任务：常见的宏任务包括： <ul><li>setTimeout</li><li>setInterval</li><li>I/O 操作</li><li>UI 事件等等</li></ul></li><li>微任务：常见的微任务包括： <ul><li>Promise.then</li><li>MutationObserver</li><li>process.nextTick 等等</li></ul></li></ul><h2 id="浏览器的事件循环机制" tabindex="-1">浏览器的事件循环机制 <a class="header-anchor" href="#浏览器的事件循环机制" aria-hidden="true">#</a></h2><p>事件循环机制是 JavaScript 语言中一个很重要的概念，它描述了 JavaScript 语言的事件驱动模型。我们既然已经了解了同步、异步任务，接下来可以了解一下事件循环机制了。</p><p>事件循环机制也就是常说的 EventLoop，是 js 处理异步操作的核心机制。<strong>全过程：</strong></p><p>1、首先会去执行同步任务，会在主线程中依次执行，直到调用栈清空；</p><p>2、然后就会检查微任务队列，检查是否有任务，有任务的话，会依次执行所有微任务，直到微任务队列清空。</p><p>3、然后就会检查宏任务队列，检查是否有任务，有任务的话，会取一个宏任务放入主线程执行。然后重复步骤 2（处理新的微任务），当宏任务执行完成后，会再次检查微任务队列，如果有新产生的微任务，立即执行所有微任务。</p><p>4、然后就是重复步骤 3，取出下一个宏任务，重复执行整个过程，形成循环（eventLoop ）</p><h2 id="nodejs-的事件循环机制" tabindex="-1">Nodejs 的事件循环机制 <a class="header-anchor" href="#nodejs-的事件循环机制" aria-hidden="true">#</a></h2><p>Node.js 的事件循环机制与浏览器有所不同，它分为 6 个阶段，按照顺序依次执行：</p><p>1、 <strong>timers 阶段</strong>：执行 setTimeout 和 setInterval 的回调函数<br> 2、 <strong>pending callbacks 阶段</strong>：执行系统操作的回调，比如 TCP 错误、UDP 错误等<br> 3、 <strong>idle, prepare 阶段</strong>：仅系统内部使用<br> 4、 <strong>poll 阶段</strong>：</p><ul><li>执行 I/O 回调</li><li>如果 poll 队列为空，会检查是否有 setImmediate 回调，如果有则进入 check 阶段</li><li>如果都没有，会等待新的 I/O 事件，并立即执行</li></ul><p>5、 <strong>check 阶段</strong>：执行 setImmediate 的回调函数<br> 6、 <strong>close callbacks 阶段</strong>：执行 close 事件的回调函数</p><p>每个阶段都有一个 FIFO 队列来执行回调。当事件循环进入某个阶段时，会执行该阶段特定的操作，然后执行该阶段队列中的回调，直到队列清空或者回调函数执行数量达到系统最大限制。</p><p><strong>Node.js 中的微任务执行时机：</strong></p><p>在 Node.js 中，微任务的执行时机比浏览器更加细粒度：</p><ul><li>在每个阶段切换之前</li><li>在每个阶段内部的每个回调之间</li></ul><p>微任务包括：</p><ul><li>process.nextTick（优先级最高）</li><li>Promise.then/catch/finally</li><li>queueMicrotask</li></ul><p><strong>示例：</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">开始</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">setTimeout</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">setImmediate</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">setImmediate</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Promise</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">process</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">nextTick</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">nextTick</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">结束</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 输出顺序：</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 开始</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 结束</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// nextTick</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Promise</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// setTimeout</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// setImmediate</span></span>
<span class="line"></span></code></pre></div><blockquote><p>需要注意的是，Node.js 的事件循环机制比浏览器更复杂，因为它需要处理更多类型的异步操作，如文件 I/O、网络 I/O 等。理解 Node.js 的事件循环机制对于编写高性能的服务端应用程序非常重要。</p></blockquote>`,31),e=[p];function t(c,r,i,F,y,D){return n(),l("div",null,e)}const d=s(o,[["render",t]]);export{C as __pageData,d as default};
