import{_ as s,o as n,c as a,a as l}from"./app.2305f01b.js";const C=JSON.parse('{"title":"React 并发模式（Concurrent Mode）","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. React 并发模式的核心概念","slug":"_1-react-并发模式的核心概念","link":"#_1-react-并发模式的核心概念","children":[]},{"level":2,"title":"2. 并发模式如何工作","slug":"_2-并发模式如何工作","link":"#_2-并发模式如何工作","children":[{"level":3,"title":"2.1 同步渲染的问题","slug":"_2-1-同步渲染的问题","link":"#_2-1-同步渲染的问题","children":[]}]},{"level":2,"title":"3. 核心机制详解","slug":"_3-核心机制详解","link":"#_3-核心机制详解","children":[{"level":3,"title":"3.1 时间切片（Time Slicing）","slug":"_3-1-时间切片-time-slicing","link":"#_3-1-时间切片-time-slicing","children":[]}]},{"level":2,"title":"4. 并发模式中的低优先级 API","slug":"_4-并发模式中的低优先级-api","link":"#_4-并发模式中的低优先级-api","children":[{"level":3,"title":"4.1 useTransition","slug":"_4-1-usetransition","link":"#_4-1-usetransition","children":[]},{"level":3,"title":"4.2 useDeferredValue","slug":"_4-2-usedeferredvalue","link":"#_4-2-usedeferredvalue","children":[]}]},{"level":2,"title":"5. 并发模式的优势与实际应用","slug":"_5-并发模式的优势与实际应用","link":"#_5-并发模式的优势与实际应用","children":[]},{"level":2,"title":"6. 总结","slug":"_6-总结","link":"#_6-总结","children":[{"level":3,"title":"知识链路总结：","slug":"知识链路总结","link":"#知识链路总结","children":[]}]}],"relativePath":"React/React并发模式.md","lastUpdated":1741225150000}'),p={name:"React/React并发模式.md"},o=l(`<h1 id="react-并发模式-concurrent-mode" tabindex="-1">React 并发模式（Concurrent Mode） <a class="header-anchor" href="#react-并发模式-concurrent-mode" aria-hidden="true">#</a></h1><p>在传统的同步渲染模式下，React 会一次性处理整个组件树的更新，这意味着如果某个渲染任务耗时较长（例如大规模数据更新或复杂计算），主线程会一直被占用，直到所有任务完成。<strong>这会导致页面在此期间无法响应用户的输入、点击等操作，造成明显的卡顿与延迟。</strong><br> 例如，当你在输入框中输入内容时，如果同时触发了大量同步渲染任务，浏览器可能无法及时响应输入事件，导致用户体验不佳。</p><p>React 并发模式正是为了解决这一问题而设计的，它将渲染任务拆分为多个小任务，允许在任务执行过程中插入更高优先级的操作，从而保证用户输入和交互的流畅性。</p><hr><h2 id="_1-react-并发模式的核心概念" tabindex="-1">1. React 并发模式的核心概念 <a class="header-anchor" href="#_1-react-并发模式的核心概念" aria-hidden="true">#</a></h2><ul><li><strong>可中断渲染</strong>：渲染任务被拆分成多个小任务（时间切片），可以在合适时机暂停、恢复或取消。</li><li><strong>自动批处理与优先级调度</strong>：内部调度器根据任务优先级动态安排任务执行，确保用户交互始终获得最高响应。</li><li><strong>低优先级 API</strong>：如 <code>useTransition</code> 与 <code>useDeferredValue</code>，允许开发者主动将某些更新标记为低优先级，从而不会阻塞高优先级的用户操作。</li></ul><hr><h2 id="_2-并发模式如何工作" tabindex="-1">2. 并发模式如何工作 <a class="header-anchor" href="#_2-并发模式如何工作" aria-hidden="true">#</a></h2><h3 id="_2-1-同步渲染的问题" tabindex="-1">2.1 同步渲染的问题 <a class="header-anchor" href="#_2-1-同步渲染的问题" aria-hidden="true">#</a></h3><p>在默认的同步渲染模式下，React 按照组件树从上到下依次执行渲染任务，任务一旦开始就会一直运行到结束。这种方式存在以下问题：</p><ul><li><strong>长任务阻塞主线程</strong>：如果任务耗时较长，会导致浏览器无法及时处理用户事件（如点击、输入）。</li><li><strong>用户体验下降</strong>：在长时间的渲染过程中，页面可能出现卡顿、掉帧甚至假死现象。</li></ul><p>React 并发模式通过将这些大任务拆分为多个小任务，允许浏览器在两个小任务之间插入高优先级任务，从而避免了主线程长时间被占用。</p><hr><h2 id="_3-核心机制详解" tabindex="-1">3. 核心机制详解 <a class="header-anchor" href="#_3-核心机制详解" aria-hidden="true">#</a></h2><h3 id="_3-1-时间切片-time-slicing" tabindex="-1">3.1 时间切片（Time Slicing） <a class="header-anchor" href="#_3-1-时间切片-time-slicing" aria-hidden="true">#</a></h3><p><strong>时间切片</strong> 的思想是将大任务拆分成多个小块，每个小块的执行时间被限制在一定范围内。这样，在每个时间片结束后，浏览器都有机会处理其他任务，从而保证整体响应性。</p><p><strong>实现原理：</strong></p><ul><li><strong>检测剩余时间</strong>：利用浏览器提供的 <code>requestIdleCallback</code> 或内部封装的 API，检查当前帧还剩多少时间（<code>deadline.timeRemaining()</code>）。</li><li><strong>拆分任务</strong>：如果剩余时间不足，暂停当前任务；反之，则继续执行。</li></ul><p><strong>示例代码：</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// workLoop：负责执行渲染任务的小块</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">workLoop</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">deadline</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 当当前帧还有剩余时间，并且任务队列不为空时，继续执行任务</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">deadline</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">timeRemaining</span><span style="color:#F07178;">() </span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">workQueue</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 执行一个单元任务</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 时间用尽或任务执行完毕后，安排下一次空闲时执行</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">requestIdleCallback</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">workLoop</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 开始任务调度</span></span>
<span class="line"><span style="color:#82AAFF;">requestIdleCallback</span><span style="color:#A6ACCD;">(workLoop)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><blockquote><p>说明：</p><ul><li>deadline.timeRemaining() 返回当前帧剩余的毫秒数。如果返回值较低，表示必须暂停任务以便浏览器处理其他高优先级任务。</li><li>这种方式保证了即使任务量大，也不会阻塞主线程，从而使用户输入等操作可以得到及时响应。</li></ul></blockquote><h2 id="_4-并发模式中的低优先级-api" tabindex="-1">4. 并发模式中的低优先级 API <a class="header-anchor" href="#_4-并发模式中的低优先级-api" aria-hidden="true">#</a></h2><p>React 提供了几个 API 来帮助开发者明确指定低优先级更新，从而避免高优先级任务被阻塞。</p><h3 id="_4-1-usetransition" tabindex="-1">4.1 useTransition <a class="header-anchor" href="#_4-1-usetransition" aria-hidden="true">#</a></h3><p><strong>useTransition</strong> 允许你将某些状态更新标记为低优先级任务，从而在这些更新进行时，React 会优先响应其他高优先级任务（如用户输入）。</p><p>示例代码：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useState</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useTransition</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">App</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">isPending</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">startTransition</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useTransition</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">setCount</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 点击按钮时，将状态更新标记为低优先级任务</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">handleClick</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">startTransition</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">setCount</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">prevCount</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">prevCount</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">handleClick</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#C792EA;">disabled</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">isPending</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">      &gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        Count: </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">isPending </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">更新中...</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="_4-2-usedeferredvalue" tabindex="-1">4.2 useDeferredValue <a class="header-anchor" href="#_4-2-usedeferredvalue" aria-hidden="true">#</a></h3><p><strong>useDeferredValue</strong> 允许你将某些计算密集型或更新频繁的值延迟到空闲时计算，从而降低对主渲染流程的干扰。</p><p>示例代码：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useState</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useDeferredValue</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">SearchResults</span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">results</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 假设 results 是需要经过复杂计算的列表</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">deferredResults</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useDeferredValue</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">results</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">deferredResults</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">map</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">item</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> (</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">id</span><span style="color:#89DDFF;">}&gt;{</span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      ))</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="_5-并发模式的优势与实际应用" tabindex="-1">5. 并发模式的优势与实际应用 <a class="header-anchor" href="#_5-并发模式的优势与实际应用" aria-hidden="true">#</a></h2><p>通过时间切片和调度机制，React 并发模式实现了以下优势：</p><p>防止 UI 卡顿：长任务被拆分为多个小任务，保证用户输入和动画得到及时响应。</p><ul><li>提高渲染效率：调度器根据任务优先级动态安排任务顺序，减少了不必要的重复渲染。</li><li>流畅的用户体验：即使在大量数据更新场景下，页面也能保持高响应性和流畅性。</li><li>在实际开发中，对于渲染复杂列表、大量数据更新或动画效果场景，合理利用 useTransition 与 useDeferredValue 可以显著提升应用性能与用户体验。</li></ul><h2 id="_6-总结" tabindex="-1">6. 总结 <a class="header-anchor" href="#_6-总结" aria-hidden="true">#</a></h2><p>React 并发模式通过时间切片和任务调度机制，实现了可中断、可恢复的渲染过程。其核心在于将大任务拆分为小任务，利用浏览器空闲时间恢复执行，确保高优先级任务（如用户输入）始终得到快速响应。同时，React 提供的 useTransition 与 useDeferredValue API 让开发者能够主动控制更新优先级，从而在实际项目中获得更流畅的交互体验。</p><h3 id="知识链路总结" tabindex="-1">知识链路总结： <a class="header-anchor" href="#知识链路总结" aria-hidden="true">#</a></h3><ul><li><strong>同步渲染的问题</strong>：长任务会阻塞主线程，导致用户输入响应缓慢。</li><li><strong>时间切片</strong>：将任务分解成小块，利用 deadline.timeRemaining() 判断是否继续执行。</li><li><strong>任务调度</strong>：内部调度器根据优先级安排任务执行，并通过 requestIdleCallback 恢复暂停任务。</li><li><strong>低优先级 API</strong>：useTransition 与 useDeferredValue 帮助开发者主动控制任务优先级，确保用户交互不受影响。</li></ul>`,39),e=[o];function t(r,c,i,F,y,D){return n(),a("div",null,e)}const d=s(p,[["render",t]]);export{C as __pageData,d as default};
