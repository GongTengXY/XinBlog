import{_ as s,o as a,c as n,a as l}from"./app.365ec0c3.js";const A=JSON.parse('{"title":"React Suspense、Lazy 原理","description":"","frontmatter":{},"headers":[{"level":2,"title":"一、React.lazy 解析","slug":"一、react-lazy-解析","link":"#一、react-lazy-解析","children":[]},{"level":2,"title":"二、Suspense 解析","slug":"二、suspense-解析","link":"#二、suspense-解析","children":[]},{"level":2,"title":"三、Suspense、lazy流程解析","slug":"三、suspense、lazy流程解析","link":"#三、suspense、lazy流程解析","children":[{"level":3,"title":"1、thenable是什么，不应该是Promise吗？","slug":"_1、thenable是什么-不应该是promise吗","link":"#_1、thenable是什么-不应该是promise吗","children":[]},{"level":3,"title":"2、attachPromiseToSuspense这个函数是干嘛用的？","slug":"_2、attachpromisetosuspense这个函数是干嘛用的","link":"#_2、attachpromisetosuspense这个函数是干嘛用的","children":[]},{"level":3,"title":"3、如果 Suspense 中有多个 lazy，React 是如何 批量 lazy 加载和调度 的？","slug":"_3、如果-suspense-中有多个-lazy-react-是如何-批量-lazy-加载和调度-的","link":"#_3、如果-suspense-中有多个-lazy-react-是如何-批量-lazy-加载和调度-的","children":[]}]},{"level":2,"title":"面试大白话总结","slug":"面试大白话总结","link":"#面试大白话总结","children":[]}],"relativePath":"React/React_Suspense&Lazy.md","lastUpdated":1754467699000}'),p={name:"React/React_Suspense&Lazy.md"},o=l(`<h1 id="react-suspense、lazy-原理" tabindex="-1">React Suspense、Lazy 原理 <a class="header-anchor" href="#react-suspense、lazy-原理" aria-hidden="true">#</a></h1><hr><p>React 的 Suspense 和 lazy 是用于组件懒加载（Code Splitting）和异步渲染管理的工具，能帮助我们实现更优雅的异步 UI 加载体验。</p><p>先举个例子吧</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> React</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Suspense</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">lazy</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> MyComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">lazy</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./MyComponent</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">App</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Suspense</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">fallback</span><span style="color:#89DDFF;">={&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">加载中...</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;}&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">MyComponent</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#FFCB6B;">Suspense</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>🌟 一句话理解</p><ul><li><p><code>React.lazy()</code>：让你“懒加载”一个组件，也就是动态 import。</p></li><li><p><code>Suspense</code>：用来包裹懒加载组件，指定加载时的 fallback（兜底 UI）。</p></li><li><p>它们的底层依赖于 React 的 Fiber 架构 和 异步渲染机制。</p></li></ul><h2 id="一、react-lazy-解析" tabindex="-1">一、React.lazy 解析 <a class="header-anchor" href="#一、react-lazy-解析" aria-hidden="true">#</a></h2><p>先来看看<code>React.lazy(fn)</code>都帮我们做了些什么？</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> MyComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">lazy</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./MyComponent</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p><code>React.lazy</code>内部相当于返回了一个「占位组件」，并记录这个 import()的 thenable。React 会根据这个 thenable 是否 resolve 来决定：</p><ul><li><p><strong>还没 resolve</strong>：不渲染组件内容，挂起（suspend）渲染。</p></li><li><p><strong>发生错误</strong>：走 error boundary。</p></li><li><p><strong>resolve 完成</strong>：真正加载这个组件，重新渲染。</p></li></ul><p>我们再看看Lazy内部是什么？</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">lazy</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">ctor</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    $$typeof</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">REACT_LAZY_TYPE</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    _ctor</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ctor</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    _status</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    _result</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p><code>React.lazy</code>返回的对象，包含三个属性：</p><ul><li><p><code>$$typeof</code>：标识这是一个 lazy 组件。</p></li><li><p><code>_ctor</code>：记录这个组件的 import() thenable。</p></li><li><p><code>_status</code> 和 <code>_result</code>：用于记录这个组件的加载状态和加载结果。</p></li></ul><p>组件加载状态说明：</p><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>-1</td><td>未初始化（initial）</td></tr><tr><td>0</td><td>正在加载中（pending）</td></tr><tr><td>1</td><td>已加载完成（resolved）</td></tr><tr><td>2</td><td>加载失败（rejected）</td></tr></tbody></table><p>当这个组件首次被渲染时，React 会调用 _ctor() 开始加载模块，把 thenable 存到 _result，并挂起当前 Fiber 节点。</p><p>这里我写一段伪代码，来模拟 <code>React.lazy</code> 的行为：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">lazyInitializer</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">payload</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_status</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 第一次初始化</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ctor</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_ctor</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">thenable</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">ctor</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 执行 import()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_status</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;">     </span><span style="color:#676E95;font-style:italic;">// 设置为 pending</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_result</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">thenable</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">thenable</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;font-style:italic;">module</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_status</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_status</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;">              </span><span style="color:#676E95;font-style:italic;">// 标记为 resolved</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_result</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">module.</span><span style="color:#A6ACCD;">default</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 存储导出的组件</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;font-style:italic;">error</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_status</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_status</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">          </span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_result</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">error</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_status</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_result</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 返回真正的组件</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">payload</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_result</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;">  </span><span style="color:#676E95;font-style:italic;">// 抛出 thenable 或 Error</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="二、suspense-解析" tabindex="-1">二、Suspense 解析 <a class="header-anchor" href="#二、suspense-解析" aria-hidden="true">#</a></h2><p>先来看看<code>Suspense</code>都帮我们做了些什么？</p><ul><li><p>当 lazy 加载的组件还没加载完成，会 <strong>“挂起”当前的渲染流程（throw Promise）</strong>。</p></li><li><p>React 向上查找最近的 <code>Suspense 组件</code>，然后渲染它的 fallback。</p></li><li><p>thenable resolve 后，重新触发渲染。</p></li></ul><h2 id="三、suspense、lazy流程解析" tabindex="-1">三、Suspense、lazy流程解析 <a class="header-anchor" href="#三、suspense、lazy流程解析" aria-hidden="true">#</a></h2><p>我们先梳理一下Suspense、lazy流程：</p><p>1、当 lazy 组件首次加载时，会调用 <code>lazyInitializer()</code>，如果组件还没加载完成，会（throw）抛出 thenable；<br> 2、此时 React 渲染流程会中断，会捕获到这个 <code>thenable</code>，此时会触发 <code>renderRootSuspend()</code> 流程，开始查找<code>Suspense边界</code>；<br> 3、其中会沿着 Fiber 向上查找最近的 <code>SuspenseBoundary</code>，根据 return链 直到找到 tag === 13 的节点，就是最近的 <code>&lt;Suspense/&gt;</code>，然后渲染它的 fallback；<br> 4、当 thenable resolve 后，React 会重新触发渲染，渲染真正的组件。</p><p>我参考<code>renderRootSuspend</code>的逻辑写了个<code>handleSuspension</code>，其伪代码如下：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">handleSuspension</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">fiber</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">promise</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">parent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fiber</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">parent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#82AAFF;">isSuspenseComponent</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">parent</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">attachPromiseToSuspense</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">parent</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">promise</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">parent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">parent</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">return</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 向上查找</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 没找到 Suspense 边界，触发全局错误</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> SuspenseComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">13</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">isSuspenseComponent</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">fiber</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fiber</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">tag</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">SuspenseComponent</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>到这里是不是会有疑问呐？</p><ul><li><p>thenable是什么，不应该是Promise吗？</p></li><li><p>attachPromiseToSuspense这个函数是干嘛用的？</p></li><li><p>如果 Suspense 中有多个 lazy，React 是如何 批量 lazy 加载和调度 的？</p></li></ul><h3 id="_1、thenable是什么-不应该是promise吗" tabindex="-1">1、thenable是什么，不应该是Promise吗？ <a class="header-anchor" href="#_1、thenable是什么-不应该是promise吗" aria-hidden="true">#</a></h3><p>React 在处理挂起逻辑时（比如 lazy()、use()、suspense cache）不强依赖标准的原生 Promise，它只关心是否有<code>.then() 方法</code>，React 就认为它是一个“可以被挂起等待”的对象 —— 这就叫 <code>thenable</code>。</p><p>在 <code>React.lazy</code> 里，thenable 就是 <code>() =&gt; import() </code>执行后返回的 Promise</p><p>为什么不是Promise呢， 是因为比如 <strong>React Cache、Server Components</strong> 可能用自定义对象，所以需要更宽泛、兼容性更强的 thenable。</p><h3 id="_2、attachpromisetosuspense这个函数是干嘛用的" tabindex="-1">2、attachPromiseToSuspense这个函数是干嘛用的？ <a class="header-anchor" href="#_2、attachpromisetosuspense这个函数是干嘛用的" aria-hidden="true">#</a></h3><p><code>attachPromiseToSuspense</code>函数的作用是，把 thenable 挂载到 Suspense 组件的 Fiber 节点，用于后续的重新挂载和恢复操作。</p><p>这个函数的主要作用有两点：</p><p><strong>1. 将 thenable 加入 SuspenseFiber 的 wakeables 列表</strong></p><p>Suspense 边界上的fiber节点，内部的 memoizedState中 维护了一个集合（通常是 wakeables Set），用于记录有哪些 thenable 让它处于“挂起”状态。<br> 这样做的目的是：一旦thenable resolved，就可以知道是哪个 Suspense 正在等待它。</p><p><strong>2. 监听 thenable 的 .then 回调，重新调度组件更新</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">suspenseFiber</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">memoizedState </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">...,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">wakeables</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> Set</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">Thenable</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">thenable</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 组件懒加载完成，Promise resolved</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 重新调度该 suspense 组件渲染</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">......</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">retrySuspenseBoundary</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">suspenseFiber</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p><strong>你可以把这看作是</strong>：</p><p>“在 Suspense 上挂一个钩子，钩住所有让它挂起的 Promise，只要这些 Promise 中任何一个完成，就重新尝试渲染。”</p><h3 id="_3、如果-suspense-中有多个-lazy-react-是如何-批量-lazy-加载和调度-的" tabindex="-1">3、如果 Suspense 中有多个 lazy，React 是如何 批量 lazy 加载和调度 的？ <a class="header-anchor" href="#_3、如果-suspense-中有多个-lazy-react-是如何-批量-lazy-加载和调度-的" aria-hidden="true">#</a></h3><p>你可能有多个 lazy() 组件，比如：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> LazyA </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">lazy</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./A</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// tenable A</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> LazyB </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">lazy</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./B</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// tenable B</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Suspense</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">fallback</span><span style="color:#89DDFF;">={&lt;</span><span style="color:#FFCB6B;">Loading</span><span style="color:#89DDFF;"> /&gt;}&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">LazyA</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">LazyB</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#FFCB6B;">Suspense</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>当这两个组件的模块都未加载完成，React 不会一个个单独处理，而是一次性挂起整个子树。</p><p>其<strong>调度核心</strong>就是 优先级 + 批处理， React 使用的是一个异步调度器 <code>Scheduler</code> + <code>Fiber work loop</code>。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 在前面提到的这一代码块中，其中的retrySuspenseBoundary会重新被调度更新。</span></span>
<span class="line"><span style="color:#A6ACCD;">thenable</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">retrySuspenseBoundary</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">suspenseFiber</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// suspenseFiber 就是触发 suspend 的 Lazy 组件</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><blockquote><p>总结一下：你用了多个懒加载子组件lazy() 同时挂起<br> 1.暂停当前执行的分支<br> 2.把所有 未 resolve 的 thenable 挂到同一个 <code>Suspense boundary</code> 上<br> 3.为这些 Promise 统一注册回调（batch retry）<br> 4.等待它们 resolve 后，整个 Suspense 边界重新进入调度渲染流程</p></blockquote><p><strong>不必担心会触发多次retry，每个thenable都注册.then()各自监听，但都指向相同的 suspenseFiber，retrySuspenseBoundary 最终触发同一个组件树的重新渲染，并且由调度器自动将多个 retry 合并执行（参考优先级/任务并发哈，这就是react中的一个内部优化。</strong></p><p>因此表现上就是：只会显示一次 fallback，然后所有懒加载组件一起加载完毕后一起展示。</p><h2 id="面试大白话总结" tabindex="-1">面试大白话总结 <a class="header-anchor" href="#面试大白话总结" aria-hidden="true">#</a></h2><p><strong>请讲一下你理解的Suspense&amp;Lazy执行流程：</strong></p><ol><li><p>react 在遍历节点时，会遇到 <code>lazy</code>懒加载组件，此时还没加载 <code>lazy</code> 中 <code>import 的组件</code>，所以会 <code>throw promise</code>，然后 <code>fiber</code> 会不断 return 根据 <code>tag === 13</code> 判断去找到最近的 <code>Suspense</code>，然后执行 <code>fallback</code>；</p></li><li><p>然后等待 <code>lazy</code> 中组件加载，其内部有 <code>status状态</code>，以及 <code>result</code> 用来存储 <code>() =&gt; import(...)</code> 的执行结果。加载的过程中，因为还没加载完成，此时 status 会变成 0，直到加载以后 status 变为 1，加载完成，此时 return加载好的组件。</p></li><li><p>然后 <code>Promise resolve</code> 后，React 会通过 <code>attachPingListener</code> -&gt; <code>retrySuspenseBoundary</code> -&gt; <code>scheduleUpdateOnFiber()</code> 把挂起的组件重新加入到调度队列中，然后由调度器（<code>React Scheduler</code>）根据优先级和空闲时间 异步地 重新执行渲染流程。</p></li></ol>`,56),e=[o];function t(c,r,y,F,D,i){return a(),n("div",null,e)}const d=s(p,[["render",t]]);export{A as __pageData,d as default};
