import{_ as s,o as n,c as a,a as l}from"./app.365ec0c3.js";const C=JSON.parse('{"title":"React 并发模式（Concurrent Mode）","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. React 并发模式的核心概念","slug":"_1-react-并发模式的核心概念","link":"#_1-react-并发模式的核心概念","children":[]},{"level":2,"title":"2. 并发模式如何工作","slug":"_2-并发模式如何工作","link":"#_2-并发模式如何工作","children":[{"level":3,"title":"2.1 时间切片（Time Slicing）","slug":"_2-1-时间切片-time-slicing","link":"#_2-1-时间切片-time-slicing","children":[]},{"level":3,"title":"2.2 任务调度（Scheduling）","slug":"_2-2-任务调度-scheduling","link":"#_2-2-任务调度-scheduling","children":[]}]},{"level":2,"title":"3. React 如何暂停与恢复任务","slug":"_3-react-如何暂停与恢复任务","link":"#_3-react-如何暂停与恢复任务","children":[{"level":3,"title":"3.1 暂停任务","slug":"_3-1-暂停任务","link":"#_3-1-暂停任务","children":[]},{"level":3,"title":"3.2 恢复任务","slug":"_3-2-恢复任务","link":"#_3-2-恢复任务","children":[]}]},{"level":2,"title":"4. 并发模式中的低优先级 API","slug":"_4-并发模式中的低优先级-api","link":"#_4-并发模式中的低优先级-api","children":[{"level":3,"title":"4.1 useTransition","slug":"_4-1-usetransition","link":"#_4-1-usetransition","children":[]},{"level":3,"title":"4.2 useDeferredValue","slug":"_4-2-usedeferredvalue","link":"#_4-2-usedeferredvalue","children":[]}]},{"level":2,"title":"5. 并发模式的优势与实际应用","slug":"_5-并发模式的优势与实际应用","link":"#_5-并发模式的优势与实际应用","children":[]},{"level":2,"title":"6. 总结","slug":"_6-总结","link":"#_6-总结","children":[{"level":3,"title":"知识链路总结：","slug":"知识链路总结","link":"#知识链路总结","children":[]}]}],"relativePath":"React/React并发模式.md","lastUpdated":1741504244000}'),p={name:"React/React并发模式.md"},o=l(`<h1 id="react-并发模式-concurrent-mode" tabindex="-1">React 并发模式（Concurrent Mode） <a class="header-anchor" href="#react-并发模式-concurrent-mode" aria-hidden="true">#</a></h1><p>在传统的同步渲染模式下，React 会一次性处理整个组件树的更新，这意味着如果某个渲染任务耗时较长（例如大规模数据更新或复杂计算），主线程会一直被占用，直到所有任务完成。<strong>这会导致页面在此期间无法响应用户的输入、点击等操作，造成明显的卡顿与延迟。</strong><br> 例如，当你在输入框中输入内容时，如果同时触发了大量同步渲染任务，浏览器可能无法及时响应输入事件，导致用户体验不佳。</p><p>React 并发模式正是为了解决这一问题而设计的，它将渲染任务拆分为多个小任务，允许在任务执行过程中插入更高优先级的操作，从而保证用户输入和交互的流畅性。</p><h2 id="_1-react-并发模式的核心概念" tabindex="-1">1. React 并发模式的核心概念 <a class="header-anchor" href="#_1-react-并发模式的核心概念" aria-hidden="true">#</a></h2><ul><li><strong>可中断渲染</strong>：渲染任务被拆分成多个小任务（时间切片），可以在合适时机暂停、恢复或取消。</li><li><strong>自动批处理与优先级调度</strong>：内部调度器根据任务优先级动态安排任务执行，确保用户交互始终获得最高响应。</li><li><strong>低优先级 API</strong>：如 <code>useTransition</code> 与 <code>useDeferredValue</code>，允许开发者主动将某些更新标记为低优先级，从而不会阻塞高优先级的用户操作。</li></ul><h2 id="_2-并发模式如何工作" tabindex="-1">2. 并发模式如何工作 <a class="header-anchor" href="#_2-并发模式如何工作" aria-hidden="true">#</a></h2><h3 id="_2-1-时间切片-time-slicing" tabindex="-1">2.1 时间切片（Time Slicing） <a class="header-anchor" href="#_2-1-时间切片-time-slicing" aria-hidden="true">#</a></h3><p><strong>时间切片</strong> 的思想是将大任务拆分成多个小任务，每个小任务的执行时间被限制在一定范围内。这样，在每个时间片结束后，浏览器都有机会处理其他任务，从而保证整体响应性。</p><p>核心原理：利用浏览器提供的空闲时间（通过 requestIdleCallback 或内部封装的 API）来决定是否继续执行当前任务。 实现要点：React 内部会不断检查剩余执行时间，通过 deadline.timeRemaining() 判断当前帧是否还有足够时间。 <strong>示例代码：</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// workLoop：负责执行渲染任务的小块</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">workLoop</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">deadline</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 当当前帧还有剩余时间，并且任务队列不为空时，继续执行</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">deadline</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">timeRemaining</span><span style="color:#F07178;">() </span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">workQueue</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 执行一个单元任务</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 如果时间不足，或者任务队列已空，则利用 requestIdleCallback 安排下次执行</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">requestIdleCallback</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">workLoop</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 开始任务调度</span></span>
<span class="line"><span style="color:#82AAFF;">requestIdleCallback</span><span style="color:#A6ACCD;">(workLoop)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><blockquote><p><strong>注释说明：</strong></p><ul><li>deadline.timeRemaining() 返回当前帧剩余的毫秒数。如果返回值很低，说明必须暂停以便浏览器有时间处理其他任务。</li><li>通过将大任务分割为多个小任务，React 就能在两个小任务之间插入高优先级任务，确保用户交互不会被阻塞。</li></ul></blockquote><h3 id="_2-2-任务调度-scheduling" tabindex="-1">2.2 任务调度（Scheduling） <a class="header-anchor" href="#_2-2-任务调度-scheduling" aria-hidden="true">#</a></h3><p>React 内部通过调度器（Scheduler）来管理任务执行顺序，确保高优先级任务（如用户输入、动画）能够即时响应，而低优先级任务则延后处理。</p><p><strong>主要调度工具：</strong></p><ul><li><p><code>requestIdleCallback</code> 利用浏览器空闲时间执行任务。尽管它的兼容性不是非常完美，但 React 对其做了封装，确保调度逻辑正常工作。</p></li><li><p><code>内部 Scheduler API</code> React 使用 unstable_scheduleCallback 来调度任务，并为任务分配不同的优先级。示例代码如下：</p></li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">unstable_scheduleCallback</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">unstable_NormalPriority</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">scheduler</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 调度一个低优先级任务</span></span>
<span class="line"><span style="color:#82AAFF;">unstable_scheduleCallback</span><span style="color:#A6ACCD;">(unstable_NormalPriority</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">执行低优先级任务</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><blockquote><p><strong>注释说明：</strong></p><ul><li>Scheduler 会根据任务的类型和优先级动态调整任务队列顺序。如果有紧急任务到来，当前任务会暂停或被重新调度。</li><li>这种调度机制保证了即使在大量数据更新或复杂计算的场景下，也能保持 UI 的响应性。</li></ul></blockquote><h2 id="_3-react-如何暂停与恢复任务" tabindex="-1">3. React 如何暂停与恢复任务 <a class="header-anchor" href="#_3-react-如何暂停与恢复任务" aria-hidden="true">#</a></h2><p>在并发模式中，React 必须不断检测是否需要暂停当前任务，以及在适当的时候恢复任务。</p><h3 id="_3-1-暂停任务" tabindex="-1">3.1 暂停任务 <a class="header-anchor" href="#_3-1-暂停任务" aria-hidden="true">#</a></h3><p>React 通过内部的 shouldYield() 方法判断是否应当暂停当前任务。其基本逻辑为：</p><p>如果当前帧剩余时间不足，或者检测到有更高优先级的任务在等待处理，则返回 true，从而让当前任务暂停。 完整代码示例：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">shouldYield</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 这里模拟判断逻辑，真实实现会更复杂，涉及优先级和时间检测</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">performance</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">now</span><span style="color:#F07178;">() </span><span style="color:#89DDFF;">%</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">16</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 简化示例：若当前毫秒数取余后小于1则暂停</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">执行一个渲染单元</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#82AAFF;">shouldYield</span><span style="color:#F07178;">()) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 如果 shouldYield() 返回 true，则暂停任务</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">暂停渲染，等待空闲时间...</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 否则，继续执行下一个渲染任务单元</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><blockquote><p><strong>注释说明：</strong></p><ul><li>shouldYield() 内部会检测 deadline.timeRemaining()（在真实的调度器中）以及任务队列状态。</li><li>当暂停时，当前任务的进度会被保存，下次恢复时能从中断的位置继续执行。</li></ul></blockquote><h3 id="_3-2-恢复任务" tabindex="-1">3.2 恢复任务 <a class="header-anchor" href="#_3-2-恢复任务" aria-hidden="true">#</a></h3><p>被暂停的任务将在浏览器空闲时通过 requestIdleCallback 恢复执行。React 调度器会从上一次暂停的位置继续执行任务单元。</p><p>完整代码示例：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">resumeWork</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 使用 requestIdleCallback 在浏览器空闲时恢复任务</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">requestIdleCallback</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">deadline</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 只要有足够时间就继续执行任务</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">deadline</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">timeRemaining</span><span style="color:#F07178;">() </span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">workQueue</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 如果任务尚未完成，继续安排下一次恢复</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">requestIdleCallback</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">resumeWork</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 启动任务恢复机制</span></span>
<span class="line"><span style="color:#82AAFF;">resumeWork</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><blockquote><p><strong>注释说明：</strong></p><ul><li>resumeWork 方法不断调用 requestIdleCallback，使得任务可以在未来的空闲时间片段中得以继续。</li><li>当高优先级任务不再阻塞时，暂停的任务便能顺利恢复执行，最终完成整个渲染过程。</li></ul></blockquote><h2 id="_4-并发模式中的低优先级-api" tabindex="-1">4. 并发模式中的低优先级 API <a class="header-anchor" href="#_4-并发模式中的低优先级-api" aria-hidden="true">#</a></h2><p>React 提供了几个 API 来帮助开发者明确指定低优先级更新，从而避免高优先级任务被阻塞。</p><h3 id="_4-1-usetransition" tabindex="-1">4.1 useTransition <a class="header-anchor" href="#_4-1-usetransition" aria-hidden="true">#</a></h3><p><strong>useTransition</strong> 允许你将某些状态更新标记为低优先级任务，从而在这些更新进行时，React 会优先响应其他高优先级任务（如用户输入）。</p><p>示例代码：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useState</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useTransition</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">App</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">isPending</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">startTransition</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useTransition</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">setCount</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 点击按钮时，将状态更新标记为低优先级任务</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">handleClick</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">startTransition</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">setCount</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">prevCount</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">prevCount</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">handleClick</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#C792EA;">disabled</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">isPending</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">      &gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        Count: </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">isPending </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">更新中...</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">p</span><span style="color:#89DDFF;">&gt;}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="_4-2-usedeferredvalue" tabindex="-1">4.2 useDeferredValue <a class="header-anchor" href="#_4-2-usedeferredvalue" aria-hidden="true">#</a></h3><p><strong>useDeferredValue</strong> 允许你将某些计算密集型或更新频繁的值延迟到空闲时计算，从而降低对主渲染流程的干扰。</p><p>示例代码：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useState</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useDeferredValue</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">SearchResults</span><span style="color:#89DDFF;">({</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">results</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">})</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 假设 results 是需要经过复杂计算的列表</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">deferredResults</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useDeferredValue</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">results</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">deferredResults</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">map</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">item</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> (</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">id</span><span style="color:#89DDFF;">}&gt;{</span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      ))</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="_5-并发模式的优势与实际应用" tabindex="-1">5. 并发模式的优势与实际应用 <a class="header-anchor" href="#_5-并发模式的优势与实际应用" aria-hidden="true">#</a></h2><p>通过时间切片和调度机制，React 并发模式实现了以下优势：</p><ul><li><strong>防止 UI 卡顿</strong>：长任务被拆分为多个小任务，保证用户输入和动画得到及时响应。</li><li><strong>提高渲染效率</strong>：调度器根据任务优先级动态安排任务顺序，减少了不必要的重复渲染。</li><li><strong>流畅的用户体验</strong>：即使在大量数据更新场景下，页面也能保持高响应性和流畅性。</li></ul><p>在实际开发中，对于渲染复杂列表、大量数据更新或动画效果场景，合理利用 useTransition 与 useDeferredValue 可以显著提升应用性能与用户体验。</p><h2 id="_6-总结" tabindex="-1">6. 总结 <a class="header-anchor" href="#_6-总结" aria-hidden="true">#</a></h2><p>React 并发模式通过时间切片和任务调度机制，实现了可中断、可恢复的渲染过程。其核心在于将大任务拆分为小任务，利用浏览器空闲时间恢复执行，确保高优先级任务（如用户输入）始终得到快速响应。同时，React 提供的 useTransition 与 useDeferredValue API 让开发者能够主动控制更新优先级，从而在实际项目中获得更流畅的交互体验。</p><h3 id="知识链路总结" tabindex="-1">知识链路总结： <a class="header-anchor" href="#知识链路总结" aria-hidden="true">#</a></h3><ul><li><strong>同步渲染的问题</strong>：长任务会阻塞主线程，导致用户输入响应缓慢。</li><li><strong>时间切片</strong>：将任务分解成小块，利用 deadline.timeRemaining() 判断是否继续执行。</li><li><strong>任务调度</strong>：内部调度器根据优先级安排任务执行，并通过 requestIdleCallback 恢复暂停任务。</li><li><strong>低优先级 API</strong>：useTransition 与 useDeferredValue 帮助开发者主动控制任务优先级，确保用户交互不受影响。</li></ul>`,47),e=[o];function t(c,r,F,y,i,D){return n(),a("div",null,e)}const d=s(p,[["render",t]]);export{C as __pageData,d as default};
